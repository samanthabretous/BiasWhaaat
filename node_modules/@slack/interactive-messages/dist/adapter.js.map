{"version":3,"sources":["../src/adapter.js"],"names":["debug","formatMatchingConstraints","matchingConstraints","ret","callbackId","Object","assign","validateConstraints","TypeError","validateActionConstraints","actionConstraints","type","SlackMessageAdapter","verificationToken","callbacks","axios","create","headers","path","Promise","resolve","then","all","express","bodyParser","app","use","urlencoded","extended","post","expressMiddleware","createServer","port","reject","server","on","listen","close","error","Error","callback","message","registerCallback","optionsConstraints","constraints","push","payload","action","actions","result","status","respond","response_url","some","fn","callbackResult","callback_id","test","unfurl","is_app_unfurl","call","catch","content"],"mappings":";;;;;;;;;;AAAA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;AACA;;;;;;AAEA,IAAMA,QAAQ,qBAAa,qCAAb,CAAd;;AAEA;;;;;;AAMA,SAASC,yBAAT,CAAmCC,mBAAnC,EAAwD;AACtD,MAAIC,MAAM,EAAV;AACA,MAAI,CAAC,sBAAcD,mBAAd,CAAL,EAAyC;AACvCC,QAAIC,UAAJ,GAAiBF,mBAAjB;AACD,GAFD,MAEO;AACLC,UAAME,OAAOC,MAAP,CAAc,EAAd,EAAkBJ,mBAAlB,CAAN;AACD;AACD,SAAOC,GAAP;AACD;;AAED;;;;;;AAMA,SAASI,mBAAT,CAA6BL,mBAA7B,EAAkD;AAChD,MAAIA,oBAAoBE,UAApB,IACA,EAAE,sBAASF,oBAAoBE,UAA7B,KAA4C,sBAASF,oBAAoBE,UAA7B,CAA9C,CADJ,EAC6F;AAC3F,WAAO,IAAII,SAAJ,CAAc,wCAAd,CAAP;AACD;;AAED,SAAO,KAAP;AACD;;AAED;;;;;;AAMA,SAASC,yBAAT,CAAmCC,iBAAnC,EAAsD;AACpD,MAAIA,kBAAkBC,IAAlB,IACA,EAAED,kBAAkBC,IAAlB,KAA2B,QAA3B,IAAuCD,kBAAkBC,IAAlB,KAA2B,QAApE,CADJ,EACmF;AACjF,WAAO,IAAIH,SAAJ,CAAc,uCAAd,CAAP;AACD;;AAED;AACA,SAAO,KAAP;AACD;;IAEoBI,mB;AACnB;;;;;AAKA,+BAAYC,iBAAZ,EAA+B;AAAA;;AAC7B,QAAI,CAAC,sBAASA,iBAAT,CAAL,EAAkC;AAChC,YAAM,IAAIL,SAAJ,CAAc,gDAAd,CAAN;AACD;;AAED,SAAKK,iBAAL,GAAyBA,iBAAzB;AACA,SAAKC,SAAL,GAAiB,EAAjB;AACA,SAAKC,KAAL,GAAa,gBAAMC,MAAN,CAAa;AACxBC,eAAS;AACP,sBAAc;AADP;AADe,KAAb,CAAb;;AAMAjB,UAAM,cAAN;AACD;;AAED;;;;;;;;;;mCAMsC;AAAA;;AAAA,UAAzBkB,IAAyB,uEAAlB,gBAAkB;;AACpC;AACA,aAAOC,QAAQC,OAAR,GAAkBC,IAAlB,CAAuB;AAAA,eAAMF,QAAQG,GAAR,CAAY,0BACvC,SADuC,8BAEvC,aAFuC,IAAZ,CAAN;AAAA,OAAvB,EAIND,IAJM,CAID,gBAA2B;AAAA;AAAA,YAAzBE,OAAyB;AAAA,YAAhBC,UAAgB;;AAC/B,YAAMC,MAAMF,SAAZ;AACAE,YAAIC,GAAJ,CAAQF,WAAWG,UAAX,CAAsB,EAAEC,UAAU,KAAZ,EAAtB,CAAR;AACAH,YAAII,IAAJ,CAASX,IAAT,EAAe,MAAKY,iBAAL,EAAf;;AAEA9B,cAAM,2BAAN,EAAmCkB,IAAnC;;AAEA,eAAO,eAAKa,YAAL,CAAkBN,GAAlB,CAAP;AACD,OAZM,CAAP;AAaD;;;0BAEKO,I,EAAM;AAAA;;AACV,aAAO,KAAKD,YAAL,GACJV,IADI,CACC;AAAA,eAAU,IAAIF,OAAJ,CAAY,UAACC,OAAD,EAAUa,MAAV,EAAqB;AAC/C,iBAAKC,MAAL,GAAcA,MAAd;AACAA,iBAAOC,EAAP,CAAU,OAAV,EAAmBF,MAAnB;AACAC,iBAAOE,MAAP,CAAcJ,IAAd,EAAoB;AAAA,mBAAMZ,QAAQc,MAAR,CAAN;AAAA,WAApB;AACAlC,gBAAM,2BAAN,EAAmCgC,IAAnC;AACD,SALe,CAAV;AAAA,OADD,CAAP;AAOD;;;2BAEM;AAAA;;AACL,aAAO,IAAIb,OAAJ,CAAY,UAACC,OAAD,EAAUa,MAAV,EAAqB;AACtC,YAAI,OAAKC,MAAT,EAAiB;AACf,iBAAKA,MAAL,CAAYG,KAAZ,CAAkB,UAACC,KAAD,EAAW;AAC3B,mBAAO,OAAKJ,MAAZ;AACA,gBAAII,KAAJ,EAAW;AACTL,qBAAOK,KAAP;AACD,aAFD,MAEO;AACLlB;AACD;AACF,WAPD;AAQD,SATD,MASO;AACLa,iBAAO,IAAIM,KAAJ,CAAU,gEAAV,CAAP;AACD;AACF,OAbM,CAAP;AAcD;;;wCAEmB;AAClB,aAAO,gDAAwB,IAAxB,CAAP;AACD;;;2BAEMrC,mB,EAAqBsC,Q,EAAU;AACpC,UAAM9B,oBAAoBT,0BAA0BC,mBAA1B,CAA1B;;AAEA,UAAMoC,QAAQ/B,oBAAoBG,iBAApB,KACZD,0BAA0BC,iBAA1B,CADF;AAEA,UAAI4B,KAAJ,EAAW;AACTtC,cAAM,oCAAN,EAA4CsC,MAAMG,OAAlD;AACA,cAAMH,KAAN;AACD;;AAED,aAAO,KAAKI,gBAAL,CAAsBhC,iBAAtB,EAAyC8B,QAAzC,CAAP;AACD;;;4BAEOtC,mB,EAAqBsC,Q,EAAU;AACrC,UAAMG,qBAAqB1C,0BAA0BC,mBAA1B,CAA3B;;AAEA,UAAMoC,QAAQ/B,oBAAoBoC,kBAApB,CAAd;AACA,UAAIL,KAAJ,EAAW;AACTtC,cAAM,qCAAN,EAA6CsC,MAAMG,OAAnD;AACA,cAAMH,KAAN;AACD;;AAED,aAAO,KAAKI,gBAAL,CAAsBC,kBAAtB,EAA0CH,QAA1C,CAAP;AACD;;AAED;;;;qCAEiBI,W,EAAaJ,Q,EAAU;AACtC;AACA,UAAI,CAAC,sBAAWA,QAAX,CAAL,EAA2B;AACzBxC,cAAM,sDAAN;AACA,cAAM,IAAIQ,SAAJ,CAAc,6BAAd,CAAN;AACD;;AAED,WAAKM,SAAL,CAAe+B,IAAf,CAAoB,CAACD,WAAD,EAAcJ,QAAd,CAApB;;AAEA,aAAO,IAAP;AACD;;;6BAEQM,O,EAAS;AAAA;;AAChB,UAAMC,SAASD,QAAQE,OAAR,IAAmBF,QAAQE,OAAR,CAAgB,CAAhB,CAAlC;AACA;AACA,UAAIC,SAAS,EAAEC,QAAQ,GAAV,EAAb;AACA,UAAMC,UAAU,SAAVA,OAAU,CAACV,OAAD,EAAa;AAC3BzC,cAAM,wBAAN;AACA,eAAO,OAAKe,KAAL,CAAWc,IAAX,CAAgBiB,QAAQM,YAAxB,EAAsCX,OAAtC,CAAP;AACD,OAHD;;AAKA,WAAK3B,SAAL,CAAeuC,IAAf,CAAoB,iBAAuB;AAAA;AAAA,YAArBT,WAAqB;AAAA,YAARU,EAAQ;;AACzC;AACA;AACA;AACA,YAAIC,uBAAJ;;AAEA,YAAIX,YAAYxC,UAAhB,EAA4B;AAC1B,cAAI,sBAASwC,YAAYxC,UAArB,KAAoC0C,QAAQU,WAAR,KAAwBZ,YAAYxC,UAA5E,EAAwF;AACtF,mBAAO,KAAP;AACD;AACD,cAAI,sBAASwC,YAAYxC,UAArB,KAAoC,CAACwC,YAAYxC,UAAZ,CAAuBqD,IAAvB,CAA4BX,QAAQU,WAApC,CAAzC,EAA2F;AACzF,mBAAO,KAAP;AACD;AACF;;AAED,YAAIT,UAAUH,YAAYjC,IAAtB,IAA8BiC,YAAYjC,IAAZ,KAAqBoC,OAAOpC,IAA9D,EAAoE;AAClE,iBAAO,KAAP;AACD;;AAED,YAAI,YAAYiC,WAAZ,KAEIA,YAAYc,MAAZ,IAAsB,CAACZ,QAAQa,aAAhC,IACC,CAACf,YAAYc,MAAb,IAAuBZ,QAAQa,aAHnC,CAAJ,EAKK;AACH,iBAAO,KAAP;AACD;;AAED,YAAI;AACFJ,2BAAiBD,GAAGM,IAAH,SAAcd,OAAd,EAAuBK,OAAvB,CAAjB;AACD,SAFD,CAEE,OAAOb,KAAP,EAAc;AACdtC,gBAAM,oBAAN,EAA4BsC,KAA5B;AACAW,mBAAS,EAAEC,QAAQ,GAAV,EAAT;AACA,iBAAO,IAAP;AACD;;AAED,YAAIK,cAAJ,EAAoB;AAClB;AACA,cAAI,OAAOA,eAAelC,IAAtB,KAA+B,UAAnC,EAA+C;AAC7CkC,2BAAelC,IAAf,CAAoB8B,OAApB,EAA6BU,KAA7B,CAAmC,UAACvB,KAAD,EAAW;AAC5CtC,oBAAM,sDAAN,EACM8C,QAAQU,WADd,EAC2BlB,MAAMG,OADjC;AAED,aAHD;AAIA,mBAAO,IAAP;AACD;AACDQ,mBAAS,EAAEC,QAAQ,GAAV,EAAeY,SAASP,cAAxB,EAAT;AACA,iBAAO,IAAP;AACD;AACD,eAAO,IAAP;AACD,OAjDD;;AAmDA,aAAON,MAAP;AACD;;;;;;kBAhLkBrC,mB","file":"adapter.js","sourcesContent":["import http from 'http';\nimport axios from 'axios';\nimport isString from 'lodash.isstring';\nimport isPlainObject from 'lodash.isplainobject';\nimport isRegExp from 'lodash.isregexp';\nimport isFunction from 'lodash.isfunction';\nimport debugFactory from 'debug';\nimport { createExpressMiddleware } from './express-middleware';\nimport { packageIdentifier } from './util';\n\nconst debug = debugFactory('@slack/interactive-messages:adapter');\n\n/**\n * Transforms various forms of matching constraints to a single standard object shape\n * @param {string|RegExp|Object} matchingConstraints - the various forms of matching constraints\n * accepted\n * @returns {Object} - an object where each matching constraint is a property\n */\nfunction formatMatchingConstraints(matchingConstraints) {\n  let ret = {};\n  if (!isPlainObject(matchingConstraints)) {\n    ret.callbackId = matchingConstraints;\n  } else {\n    ret = Object.assign({}, matchingConstraints);\n  }\n  return ret;\n}\n\n/**\n * Validates general properties of a matching constraints object\n * @param {Object} matchingConstraints - object describing the constraints on a callback\n * @return {Error|false} - a false value represents successful validation, otherwise an error to\n * describe why validation failed.\n */\nfunction validateConstraints(matchingConstraints) {\n  if (matchingConstraints.callbackId &&\n      !(isString(matchingConstraints.callbackId) || isRegExp(matchingConstraints.callbackId))) {\n    return new TypeError('Callback ID must be a string or RegExp');\n  }\n\n  return false;\n}\n\n/**\n * Validates properties of a matching constraints object specific to registering an action\n * @param {Object} matchingConstraints - object describing the constraints on a callback\n * @return {Error|false} - a false value represents successful validation, otherwise an error to\n * describe why validation failed.\n */\nfunction validateActionConstraints(actionConstraints) {\n  if (actionConstraints.type &&\n      !(actionConstraints.type === 'select' || actionConstraints.type === 'button')) {\n    return new TypeError('Type must be \\'select\\' or \\'button\\'');\n  }\n\n  // We don't need to validate unfurl, we'll just cooerce it to a boolean\n  return false;\n}\n\nexport default class SlackMessageAdapter {\n  /**\n   * Create a message adapter.\n   *\n   * @param {string} verificationToken - Slack app verification token used to authenticate request\n   */\n  constructor(verificationToken) {\n    if (!isString(verificationToken)) {\n      throw new TypeError('SlackMessageAdapter needs a verification token');\n    }\n\n    this.verificationToken = verificationToken;\n    this.callbacks = [];\n    this.axios = axios.create({\n      headers: {\n        'User-Agent': packageIdentifier(),\n      },\n    });\n\n    debug('instantiated');\n  }\n\n  /**\n   * Create a server that's ready to serve requests from Slack's interactive messages.\n   *\n   * @param {string} [path=/slack/actions] - The path portion of the URL where the server will\n   * listen for requests from Slack's interactive messages.\n   */\n  createServer(path = '/slack/actions') {\n    // TODO: more options (like https)\n    return Promise.resolve().then(() => Promise.all([\n      import('express'),\n      import('body-parser'),\n    ]))\n    .then(([express, bodyParser]) => {\n      const app = express();\n      app.use(bodyParser.urlencoded({ extended: false }));\n      app.post(path, this.expressMiddleware());\n\n      debug('server created - path: %s', path);\n\n      return http.createServer(app);\n    });\n  }\n\n  start(port) {\n    return this.createServer()\n      .then(server => new Promise((resolve, reject) => {\n        this.server = server;\n        server.on('error', reject);\n        server.listen(port, () => resolve(server));\n        debug('server started - port: %s', port);\n      }));\n  }\n\n  stop() {\n    return new Promise((resolve, reject) => {\n      if (this.server) {\n        this.server.close((error) => {\n          delete this.server;\n          if (error) {\n            reject(error);\n          } else {\n            resolve();\n          }\n        });\n      } else {\n        reject(new Error('SlackMessageAdapter cannot stop when it did not start a server'));\n      }\n    });\n  }\n\n  expressMiddleware() {\n    return createExpressMiddleware(this);\n  }\n\n  action(matchingConstraints, callback) {\n    const actionConstraints = formatMatchingConstraints(matchingConstraints);\n\n    const error = validateConstraints(actionConstraints) ||\n      validateActionConstraints(actionConstraints);\n    if (error) {\n      debug('action could not be registered: %s', error.message);\n      throw error;\n    }\n\n    return this.registerCallback(actionConstraints, callback);\n  }\n\n  options(matchingConstraints, callback) {\n    const optionsConstraints = formatMatchingConstraints(matchingConstraints);\n\n    const error = validateConstraints(optionsConstraints);\n    if (error) {\n      debug('options could not be registered: %s', error.message);\n      throw error;\n    }\n\n    return this.registerCallback(optionsConstraints, callback);\n  }\n\n  /* @private */\n\n  registerCallback(constraints, callback) {\n    // Validation\n    if (!isFunction(callback)) {\n      debug('did not register callback because its not a function');\n      throw new TypeError('callback must be a function');\n    }\n\n    this.callbacks.push([constraints, callback]);\n\n    return this;\n  }\n\n  dispatch(payload) {\n    const action = payload.actions && payload.actions[0];\n    // The following result value represents \"no replacement\"\n    let result = { status: 200 };\n    const respond = (message) => {\n      debug('sending async response');\n      return this.axios.post(payload.response_url, message);\n    };\n\n    this.callbacks.some(([constraints, fn]) => {\n      // Returning false in this function continues the iteration, and returning true ends it.\n      // The pattern is that we assign a value to `result` and then return true. We only desire one\n      // result for the response.\n      let callbackResult;\n\n      if (constraints.callbackId) {\n        if (isString(constraints.callbackId) && payload.callback_id !== constraints.callbackId) {\n          return false;\n        }\n        if (isRegExp(constraints.callbackId) && !constraints.callbackId.test(payload.callback_id)) {\n          return false;\n        }\n      }\n\n      if (action && constraints.type && constraints.type !== action.type) {\n        return false;\n      }\n\n      if ('unfurl' in constraints &&\n           (\n             (constraints.unfurl && !payload.is_app_unfurl) ||\n             (!constraints.unfurl && payload.is_app_unfurl)\n           )\n         ) {\n        return false;\n      }\n\n      try {\n        callbackResult = fn.call(this, payload, respond);\n      } catch (error) {\n        debug('callback error: %o', error);\n        result = { status: 500 };\n        return true;\n      }\n\n      if (callbackResult) {\n        // Checking for Promise type\n        if (typeof callbackResult.then === 'function') {\n          callbackResult.then(respond).catch((error) => {\n            debug('async error for callback. callback_id: %s, error: %s',\n                  payload.callback_id, error.message);\n          });\n          return true;\n        }\n        result = { status: 200, content: callbackResult };\n        return true;\n      }\n      return true;\n    });\n\n    return result;\n  }\n}\n"]}